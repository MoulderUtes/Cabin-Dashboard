<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cabin Weather Dashboard</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1410;
            padding: 20px;
            color: #e8e6e3;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #2d2520;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.5);
        }

        h1 {
            color: #d4c5a9;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .header-info {
            color: #a69880;
            font-size: 12px;
            margin-bottom: 20px;
        }

        /* Quick View Section */
        .quick-view {
            background: #3a332d;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #4a433d;
            margin-bottom: 20px;
        }

        .quick-view h2 {
            color: #d4c5a9;
            font-size: 16px;
            margin-bottom: 15px;
            border-bottom: 2px solid #5a6d4f;
            padding-bottom: 8px;
        }

        .quick-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .stat-box {
            background: linear-gradient(135deg, #4a5d3f 0%, #3a4d2f 100%);
            color: #e8e6e3;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #5a6d4f;
            transition: transform 0.2s;
        }

        .stat-box:hover {
            transform: translateY(-2px);
        }

        .stat-box.snow {
            background: linear-gradient(135deg, #556b5a 0%, #3d5247 100%);
            border: 1px solid #6a7d6f;
        }

        .stat-box.temp {
            background: linear-gradient(135deg, #6b5544 0%, #5a4433 100%);
            border: 1px solid #7a6554;
        }

        .stat-box.wind {
            background: linear-gradient(135deg, #4a5a6b 0%, #3a4a5b 100%);
            border: 1px solid #5a6a7b;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin: 8px 0;
            color: #d4c5a9;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.9;
            color: #c8bfa8;
        }

        .stat-source {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 3px;
            color: #a89f88;
        }

        /* Section Styles */
        .section {
            background: #3a332d;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #4a433d;
            margin-bottom: 20px;
        }

        .section h3 {
            color: #d4c5a9;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #5a6d4f;
        }

        /* Loading and Status */
        .loading {
            text-align: center;
            color: #a69880;
            padding: 20px;
            font-style: italic;
        }

        .error {
            background: #5a3a3a;
            color: #ff8080;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #7a4a4a;
            margin-bottom: 15px;
        }

        /* Map Container */
        #map {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            border: 1px solid #4a433d;
        }

        /* Weather Section Styles */
        .weather-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .weather-card {
            background: linear-gradient(135deg, #4a5d3f 0%, #3a4d2f 100%);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #5a6d4f;
        }

        .weather-card h4 {
            color: #d4c5a9;
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid #5a6d4f;
            padding-bottom: 6px;
        }

        .weather-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 12px;
        }

        .weather-label {
            color: #c8bfa8;
        }

        .weather-value {
            color: #d4c5a9;
            font-weight: bold;
        }

        /* Forecast Cards */
        .forecast-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .forecast-day-card {
            background: linear-gradient(135deg, #4a5d3f 0%, #3a4d2f 100%);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #5a6d4f;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .forecast-day-card:hover {
            transform: translateY(-3px);
            border-color: #6b9d59;
            box-shadow: 0 4px 12px rgba(107, 157, 89, 0.2);
        }

        .forecast-day-name {
            color: #d4c5a9;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .forecast-temps {
            display: flex;
            justify-content: space-around;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .forecast-temp-label {
            color: #a89f88;
            display: block;
            font-size: 9px;
        }

        .forecast-temp-value {
            color: #d4c5a9;
            font-weight: bold;
        }

        .forecast-condition {
            color: #c8bfa8;
            font-size: 11px;
            margin-bottom: 6px;
        }

        .forecast-details {
            font-size: 10px;
            color: #a89f88;
            line-height: 1.3;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #2d2520;
            padding: 0;
            border-radius: 10px;
            border: 1px solid #4a433d;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
        }

        .modal-header {
            background: #3a332d;
            padding: 20px;
            border-bottom: 1px solid #4a433d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            color: #d4c5a9;
            margin: 0;
            font-size: 18px;
        }

        .modal-close {
            color: #a69880;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: #d4c5a9;
        }

        .modal-body {
            padding: 20px;
        }

        .hourly-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }

        .hourly-card {
            background: linear-gradient(135deg, #4a5d3f 0%, #3a4d2f 100%);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #5a6d4f;
            text-align: center;
        }

        .hourly-time {
            color: #d4c5a9;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .hourly-temp {
            color: #d4a574;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 6px;
        }

        .hourly-info {
            font-size: 10px;
            color: #c8bfa8;
            line-height: 1.3;
        }

        .hourly-condition {
            color: #6b9d59;
            font-size: 9px;
            margin-top: 4px;
        }

        .no-hourly-message {
            background: #5a3a3a;
            color: #ff8080;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #7a4a4a;
            text-align: center;
        }

        /* Soil Data Section */
        .soil-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .soil-card {
            background: linear-gradient(135deg, #5a4a6b 0%, #4a3a5b 100%);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #6a5a7b;
        }

        .soil-card h4 {
            color: #d4c5a9;
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid #6a5a7b;
            padding-bottom: 6px;
        }

        .soil-depth-group {
            margin-bottom: 12px;
        }

        .soil-depth-title {
            font-size: 11px;
            color: #b8b0a8;
            text-transform: uppercase;
            margin-bottom: 4px;
            font-weight: bold;
        }

        .soil-value {
            font-size: 12px;
            color: #d4c5a9;
            padding: 3px 0;
        }

        /* Soil Chart Containers */
        .soil-chart-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .chart-box {
            background: #3a332d;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a433d;
            display: flex;
            flex-direction: column;
        }

        .chart-box h4 {
            color: #d4c5a9;
            font-size: 14px;
            margin-bottom: 15px;
            border-bottom: 1px solid #4a433d;
            padding-bottom: 8px;
            flex-shrink: 0;
        }

        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 300px;
            flex-grow: 1;
        }

        .chart-wrapper canvas {
            display: block;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 20px;
            color: #a69880;
            font-size: 11px;
            border-top: 1px solid #4a433d;
            margin-top: 20px;
        }

        footer a {
            color: #6b9d59;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Status Indicators */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-ok {
            background: #6b9d59;
        }

        .status-warning {
            background: #d4a574;
        }

        .status-error {
            background: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèîÔ∏è Cabin Weather Dashboard</h1>
        <div class="header-info">
            Timberline, Utah ‚Ä¢ 39.8918¬∞N, 110.6824¬∞W ‚Ä¢ 8,720 ft
        </div>

        <!-- Quick View Section -->
        <div class="quick-view">
            <h2>‚ö° Quick View</h2>
            <div class="quick-stats" id="quickStats">
                <div class="loading">Loading current conditions...</div>
            </div>
        </div>

        <!-- Maps Section -->
        <div class="section">
            <h3>üó∫Ô∏è Interactive Map</h3>
            <div style="margin-bottom: 15px; display: flex; gap: 20px; flex-wrap: wrap;">
                <div>
                    <label for="background-layer-select" style="color: #c8bfa8; margin-right: 10px; font-size: 12px;">Background:</label>
                    <select id="background-layer-select" onchange="updateBackgroundLayer()" style="padding: 5px; background: #3a332d; color: #e8e6e3; border: 1px solid #5a4d47; border-radius: 4px;">
                        <option value="TRUE_COLOR_MOST_RECENT">Sentinel-2 Most Recent RGB</option>
                        <option value="TRUE_COLOR_50_CC">Sentinel-2 < 50% Clouds RGB</option>
                        <option value="TRUE_COLOR_LEAST_CLOUD">Sentinel-2 Least Cloudy RGB</option>
                        <option value="NDSI">Sentinel-2 Snow Index - NDSI</option>
                        <option value="OSM_STREET">OpenStreetMap - Street Map</option>
                        <option value="USGS_TOPO">USGS Topographic Map</option>
                        <option value="ESRI_IMAGERY">ESRI World Imagery</option>
                    </select>
                    <button onclick="centerOnCabin()" style="margin-left: 10px; padding: 5px 10px; background: #5a4d47; color: #e8e6e3; border: 1px solid #7a6d67; border-radius: 4px; cursor: pointer;">Center on Cabin</button>
                </div>
                <div style="display: flex; gap: 15px; align-items: center;">
                    <label for="overlay-layer-select" style="color: #c8bfa8; margin-right: 10px; font-size: 12px;">Overlay:</label>
                    <select id="overlay-layer-select" onchange="updateOverlayLayer()" style="padding: 5px; background: #3a332d; color: #e8e6e3; border: 1px solid #5a4d47; border-radius: 4px;">
                        <option value="NONE">None</option>
                        <option value="RADAR">Weather Radar (RainViewer)</option>
                        <option value="TEMP">Temperature (OWM)</option>
                        <option value="PRECIP_24H">Precipitation (NOAA)</option>
                    </select>
                    <label style="color: #c8bfa8; font-size: 12px;">
                        <input type="checkbox" id="show-cameras" onchange="toggleCameras()" checked>
                        Traffic Cameras
                    </label>
                </div>
            </div>
            <div id="map" style="height: 600px; margin-bottom: 15px;"></div>
            <div id="map-image-date" style="font-size: 11px; color: #a89f88; padding: 8px; background: #2a2420; border-radius: 3px;">
                <span id="map-source">Source: --</span><br>
                <span id="map-date-acquired">Image date: --</span><br>
                <span id="map-cache-status">Cache status: Loading...</span>
            </div>
        </div>

        <!-- Traffic Camera Section -->
        <div class="section">
            <h3>üìπ UDOT Traffic Cameras</h3>
            <div style="margin-bottom: 15px; font-size: 12px; color: #a69880;">
                Click on camera markers (green/gray dots) on the map above to view different traffic cameras and weather conditions. Green = Active, Gray = Inactive.
            </div>

            <div id="camera-grid" style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- Camera Feed -->
                <div>
                    <div id="camera-name" style="color: #d4c5a9; margin-bottom: 10px; font-weight: bold;">No camera selected</div>
                    <iframe id="camera-iframe" src="about:blank"
                            style="width: 100%; height: 400px; border: 1px solid #5a4d47; border-radius: 4px; background: #000;"></iframe>
                </div>

                <!-- Camera Weather Panel -->
                <div id="camera-weather-panel" style="background: #2d2520; padding: 15px; border-radius: 8px; border: 1px solid #5a4d47;">
                    <h4 style="color: #d4c5a9; margin: 0 0 10px 0; font-size: 14px; border-bottom: 1px solid #5a4d47; padding-bottom: 8px;">üå°Ô∏è Station Weather</h4>
                    <div id="camera-weather-conditions" style="font-size: 12px; color: #c8bfa8; line-height: 1.8;">
                        <div style="color: #8a8170;">Click a camera marker on the map to view weather</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Weather Section -->
        <div class="section">
            <h3>üå§Ô∏è Weather Forecast</h3>
            <div style="margin-bottom: 15px; font-size: 12px; color: #a69880;">
                7-day temperature forecast. Click on any day to view hourly details.
            </div>
            <div id="weather-data-info" style="font-size: 10px; color: #8a7a68; margin-bottom: 10px; padding: 8px; background: #2a2420; border-radius: 3px;">
                <span id="weather-source">Source: OpenWeatherMap</span><br>
                <span id="weather-time">Last updated: --:--:-- | </span>
                <span id="weather-cache">Status: Loading...</span>
            </div>
            <div class="weather-chart-container">
                <div class="chart-box" style="grid-column: 1 / -1;">
                    <h4>7-Day Temperature Forecast</h4>
                    <div class="chart-wrapper" style="height: 250px;">
                        <canvas id="hourly-temp-canvas"></canvas>
                    </div>
                </div>
            </div>

            <!-- 7-Day Forecast Cards -->
            <div class="forecast-cards-container" id="forecastCardsContainer" style="margin-top: 20px;">
                <div class="loading">Loading forecast...</div>
            </div>
        </div>

        <!-- Hourly Modal Popup -->
        <div id="hourlyModal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="modalDayName" style="color: #d4c5a9;"></h3>
                    <span class="modal-close" onclick="closeHourlyModal()">&times;</span>
                </div>
                <div class="modal-body" id="hourlyModalContent">
                    <div class="chart-box" style="height: 400px;">
                        <div class="chart-wrapper" style="height: 350px;">
                            <canvas id="hourly-chart-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Soil Data Section -->
        <div class="section">
            <h3>üå± Soil Conditions</h3>
            <div id="soil-data-info" style="font-size: 10px; color: #8a7a68; margin-bottom: 15px; padding: 8px; background: #2a2420; border-radius: 3px;">
                <span id="soil-source">Source: USDA SNOTEL</span><br>
                <span id="soil-time">Last updated: --:--:-- | </span>
                <span id="soil-cache">Status: Loading...</span>
            </div>

            <div class="soil-chart-container">
                <div class="chart-box">
                    <h4>Soil Moisture (%)</h4>
                    <div class="chart-wrapper">
                        <canvas id="soil-moisture-canvas"></canvas>
                    </div>
                </div>
                <div class="chart-box">
                    <h4>Soil Temperature (¬∞F)</h4>
                    <div class="chart-wrapper">
                        <canvas id="soil-temp-canvas"></canvas>
                    </div>
                </div>
                <div class="chart-box" style="grid-column: 1 / -1;">
                    <h4>Snow Depth History (inches)</h4>
                    <div class="chart-wrapper" style="height: 250px;">
                        <canvas id="snow-depth-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div style="border-top: 1px solid #5a4d47; padding-top: 15px; margin-top: 20px;">
                <h4 style="color: #d4c5a9; margin: 0 0 10px 0;">üìä Data Sources & Credits</h4>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 15px; font-size: 12px;">
                    <div>
                        <strong style="color: #c8bfa8;">Weather & Forecasting</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; color: #a89f88;">
                            <li><a href="https://openweathermap.org/" target="_blank" style="color: #6b9d59;">OpenWeatherMap</a> - 7-day forecast, real-time weather</li>
                            <li><a href="https://www.weather.gov/" target="_blank" style="color: #6b9d59;">NOAA/NWS</a> - Weather alerts, radar, warnings</li>
                        </ul>
                    </div>
                    <div>
                        <strong style="color: #c8bfa8;">Soil & Snow Data</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; color: #a89f88;">
                            <li><a href="https://wcc.sc.egov.usda.gov/" target="_blank" style="color: #6b9d59;">USDA SNOTEL</a> - Soil moisture, temperature, snow depth</li>
                            <li><a href="https://water.usgs.gov/osw/WaterWatch/" target="_blank" style="color: #6b9d59;">USGS WaterWatch</a> - Water resources monitoring</li>
                        </ul>
                    </div>
                    <div>
                        <strong style="color: #c8bfa8;">Traffic & Road Conditions</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; color: #a89f88;">
                            <li><a href="https://www.udottraffic.utah.gov/" target="_blank" style="color: #6b9d59;">UDOT Traffic</a> - Live cameras, weather stations, road conditions</li>
                        </ul>
                    </div>
                    <div>
                        <strong style="color: #c8bfa8;">Satellite Imagery</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; color: #a89f88;">
                            <li><a href="https://www.sentinel-hub.com/" target="_blank" style="color: #6b9d59;">Sentinel Hub</a> - Sentinel-2 satellite imagery, snow indices</li>
                            <li><a href="https://www.openstreetmap.org/" target="_blank" style="color: #6b9d59;">OpenStreetMap</a> - Base map layer</li>
                        </ul>
                    </div>
                    <div>
                        <strong style="color: #c8bfa8;">Mapping & Visualization</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; color: #a89f88;">
                            <li><a href="https://leafletjs.com/" target="_blank" style="color: #6b9d59;">Leaflet</a> - Interactive mapping</li>
                            <li><a href="https://www.chartjs.org/" target="_blank" style="color: #6b9d59;">Chart.js</a> - Data visualization & charts</li>
                        </ul>
                    </div>
                    <div>
                        <strong style="color: #c8bfa8;">Technologies</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; color: #a89f88;">
                            <li>Python Cache Server - Data aggregation & caching</li>
                            <li>Chart.js - Advanced data visualization</li>
                            <li>Leaflet.js - Interactive web mapping</li>
                        </ul>
                    </div>
                </div>

                <div style="text-align: center; font-size: 11px; color: #7a6a58; border-top: 1px solid #5a4d47; padding-top: 10px;">
                    <p>Last updated: <span id="lastUpdate">--</span> | Data refreshed every 5 minutes</p>
                    <p>üìç Cabin Location: 39.8918¬∞N, 110.6824¬∞W | Elevation: ~7,200 ft</p>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Configuration - will be loaded from server
        let CACHE_SERVER = window.location.origin;
        let CABIN_LAT = 39.8918;
        let CABIN_LON = -110.6824;
        let SH_CONFIG_ID = '';
        let OWM_API_KEY = '';

        // Load configuration from server
        async function loadConfig() {
            try {
                const response = await fetch(`${window.location.origin}/api/config`);
                if (response.ok) {
                    const config = await response.json();
                    CABIN_LAT = config.cabin_lat || CABIN_LAT;
                    CABIN_LON = config.cabin_lon || CABIN_LON;
                    SH_CONFIG_ID = config.sentinel_hub_config_id || '';
                    OWM_API_KEY = config.owm_api_key || '';
                    // Use custom API base URL if provided, otherwise use current origin
                    if (config.api_base_url) {
                        CACHE_SERVER = config.api_base_url;
                    }
                    console.log('Configuration loaded from server, API URL:', CACHE_SERVER);
                }
            } catch (error) {
                console.warn('Failed to load config from server, using defaults:', error);
            }
        }

        let map;
        let wmsLayer = null;
        let baseLayer = null;
        let overlayLayers = {};  // Store multiple overlay layers: {layerName: leafletLayer}
        let layerDates = {};  // Store dates per layer: {layerName: dateStr}
        let currentSentinelLayer = null;  // Track which Sentinel layer is currently displayed
        let sentinelLayerDateCache = {};  // Cache dates to avoid refetching

        // Chart instances
        let soilMoistureChart = null;
        let soilTempChart = null;
        let snowDepthChart = null;
        let hourlyChart = null;

        // Reusable plugin for soil moisture zone lines
        const soilMoistureZonesPlugin = {
            id: 'soilMoistureZones',
            afterDatasetsDraw(chart) {
                // Only run if this plugin is explicitly enabled with {}
                const plugins = chart.options?.plugins || {};
                const pluginConfig = plugins.soilMoistureZones;
                // Must be present AND not false
                if (pluginConfig === undefined || pluginConfig === false) return;
                
                const yAxis = chart.scales.y;
                const xAxis = chart.scales.x;
                
                if (!yAxis || !xAxis) return;
                
                // Soil moisture zones based on research:
                // Dry: 0-20%, Firm: 20-40%, Moist: 40-70%, Muddy/Saturated: 70-100%
                const zones = [
                    { value: 20, color: 'rgba(184, 134, 11, 0.7)', label: 'Dry‚Üí' },
                    { value: 40, color: 'rgba(210, 180, 140, 0.7)', label: 'Firm‚Üí' },
                    { value: 70, color: 'rgba(160, 120, 80, 0.7)', label: 'Moist‚Üí' }
                ];
                
                const ctx = chart.ctx;
                ctx.save();
                
                zones.forEach(zone => {
                    const yPixel = yAxis.getPixelForValue(zone.value);
                    
                    // Only draw if within visible range
                    if (isNaN(yPixel) || yPixel < yAxis.top || yPixel > yAxis.bottom) return;
                    
                    // Draw solid line
                    ctx.strokeStyle = zone.color;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(xAxis.left, yPixel);
                    ctx.lineTo(xAxis.right, yPixel);
                    ctx.stroke();
                    
                    // Draw label
                    ctx.setLineDash([]);
                    ctx.fillStyle = zone.color;
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(zone.label + zone.value + '%', xAxis.right - 8, yPixel);
                });
                
                ctx.restore();
            }
        };

        // Reusable plugin for drawing freezing point line (32¬∞F / 0¬∞C)
        const freezingPointPlugin = {
            id: 'freezingPointLine',
            afterDatasetsDraw(chart) {
                // Only run if this plugin is explicitly enabled with {}
                const plugins = chart.options?.plugins || {};
                const pluginConfig = plugins.freezingPointLine;
                // Must be present AND not false
                if (pluginConfig === undefined || pluginConfig === false) return;
                
                const yAxis = chart.scales.y;
                const xAxis = chart.scales.x;
                
                if (!yAxis || !xAxis) return;
                
                const freezingF = 32; // 32¬∞F = 0¬∞C
                const yPixel = yAxis.getPixelForValue(freezingF);
                
                // Only draw if freezing point is within visible range
                if (isNaN(yPixel) || yPixel < yAxis.top || yPixel > yAxis.bottom) return;
                
                const ctx = chart.ctx;
                ctx.save();
                
                // Draw dashed line
                ctx.strokeStyle = 'rgba(74, 158, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(xAxis.left, yPixel);
                ctx.lineTo(xAxis.right, yPixel);
                ctx.stroke();
                
                // Draw label on the right side
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(74, 158, 255, 0.8)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText('32¬∞F', xAxis.right - 8, yPixel);
                
                ctx.restore();
            }
        };

        // Register both plugins globally - they check their own config to decide whether to run
        Chart.register(soilMoistureZonesPlugin);
        Chart.register(freezingPointPlugin);

        // Initialize map
        function centerOnCabin() {
            map.setView([CABIN_LAT, CABIN_LON], 14);
        }

        // Check if there's newer Sentinel-2 data available and update cache
        async function checkAndUpdateSentinelCache(layerName) {
            // First get the current cached date
            const cachedDate = sentinelLayerDateCache[layerName];

            // Fetch the actual latest date from Copernicus
            const latestDate = await getSentinelLayerDate(layerName);

            if (!cachedDate || !latestDate) {
                return;
            }

            console.log(`${layerName} - Cached: ${cachedDate}, Latest: ${latestDate}`);

            // Parse dates for comparison
            const cached = new Date(cachedDate);
            const latest = new Date(latestDate);

            // If newer data exists, we need to clear the old cache
            if (latest > cached) {
                console.warn(`Newer Sentinel-2 data available for ${layerName}! Clearing old cache...`);

                // Send request to server to clear old cache for this layer
                try {
                    await fetch(`${CACHE_SERVER}/api/clear-sentinel-cache?layer=${layerName}`, {
                        method: 'POST'
                    });
                    console.log(`Cache cleared for ${layerName}`);

                    // Update the cached date
                    sentinelLayerDateCache[layerName] = latestDate;

                    // Refresh the map tiles
                    if (wmsLayer) {
                        map.removeLayer(wmsLayer);
                        const today = new Date();
                        const todayStr = today.toISOString().split('T')[0];
                        wmsLayer = L.tileLayer.wms(`${CACHE_SERVER}/api/sentinel`, {
                            layers: layerName,
                            format: 'image/png',
                            transparent: false,
                            time: `2015-06-23/${todayStr}`,
                            attribution: 'Sentinel-2 ¬© ESA',
                            maxZoom: 25,
                            maxNativeZoom: 18
                        });
                        wmsLayer.addTo(map);
                        document.getElementById('map-date-acquired').textContent = `Image date: ${latestDate}`;
                    }
                } catch (error) {
                    console.error('Error clearing cache:', error);
                }
            }
        }

        // Get Sentinel-2 imagery acquisition date for a layer
        async function getSentinelLayerDate(layerName) {
            // Check if we already have this layer's date cached
            if (sentinelLayerDateCache[layerName]) {
                console.log(`Using cached date for ${layerName}: ${sentinelLayerDateCache[layerName]}`);
                return sentinelLayerDateCache[layerName];
            }

            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];  // Format: YYYY-MM-DD

            try {
                // GetFeatureInfo request to Copernicus to get imagery date
                const infoUrl = `https://sh.dataspace.copernicus.eu/ogc/wms/${SH_CONFIG_ID}?` +
                    `SERVICE=WMS&` +
                    `REQUEST=GetFeatureInfo&` +
                    `LAYERS=${layerName}&` +
                    `QUERY_LAYERS=${layerName}&` +
                    `BBOX=${CABIN_LAT - 0.001},${CABIN_LON - 0.001},${CABIN_LAT + 0.001},${CABIN_LON + 0.001}&` +
                    `CRS=EPSG:4326&` +
                    `WIDTH=100&` +
                    `HEIGHT=100&` +
                    `I=50&` +
                    `J=50&` +
                    `INFO_FORMAT=application/json&` +
                    `TIME=2015-06-23/${todayStr}&` +
                    `VERSION=1.3.0`;

                const response = await fetch(infoUrl);
                const data = await response.json();

                if (data && data.features && data.features[0] && data.features[0].properties) {
                    const dateStr = data.features[0].properties.date;
                    if (dateStr) {
                        const date = new Date(dateStr);
                        const formattedDate = date.toLocaleDateString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            year: 'numeric'
                        });
                        // Cache the formatted date
                        sentinelLayerDateCache[layerName] = formattedDate;
                        layerDates[layerName] = dateStr;
                        console.log(`Fetched date for ${layerName}: ${formattedDate}`);
                        return formattedDate;
                    }
                }
            } catch (error) {
                console.error(`Error fetching Sentinel-2 date for ${layerName}:`, error);
            }
            return null;
        }

        function initializeMap() {
            map = L.map('map').setView([CABIN_LAT, CABIN_LON], 13);

            // Add base layer ONLY - will be replaced when user selects
            baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Add cabin marker
            L.marker([CABIN_LAT, CABIN_LON], {
                title: 'Cabin Location'
            }).addTo(map).bindPopup('Timberline Cabin<br>8,720 ft');

            // Set initial background layer
            updateBackgroundLayer();
        }

        function updateBackgroundLayer() {
            const layerName = document.getElementById('background-layer-select').value;

            // Remove old layers
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
                wmsLayer = null;
            }
            if (baseLayer) {
                map.removeLayer(baseLayer);
                baseLayer = null;
            }

            // Handle different background types
            if (layerName === 'OSM_STREET') {
                baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                });
                baseLayer.addTo(map);

                document.getElementById('map-source').textContent = 'Source: OpenStreetMap';
                document.getElementById('map-date-acquired').textContent = 'Image date: Current';
                document.getElementById('map-cache-status').textContent = 'Cache status: N/A (Direct)';

            } else if (layerName === 'USGS_TOPO') {
                baseLayer = L.tileLayer(`${CACHE_SERVER}/api/wms?url=https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}`, {
                    attribution: 'USGS',
                    maxZoom: 16
                });
                baseLayer.addTo(map);

                document.getElementById('map-source').textContent = 'Source: USGS (Cached)';
                document.getElementById('map-date-acquired').textContent = 'Image date: Current';
                document.getElementById('map-cache-status').textContent = 'Cache status: ‚úÖ Cached';

            } else if (layerName === 'ESRI_IMAGERY') {
                baseLayer = L.tileLayer(`${CACHE_SERVER}/api/wms?url=https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}`, {
                    attribution: '¬© Esri',
                    maxZoom: 19
                });
                baseLayer.addTo(map);

                document.getElementById('map-source').textContent = 'Source: ESRI (Cached)';
                document.getElementById('map-date-acquired').textContent = 'Image date: Current';
                document.getElementById('map-cache-status').textContent = 'Cache status: ‚úÖ Cached';

            } else {
                // Sentinel-2 satellite imagery via cache server proxy
                currentSentinelLayer = layerName;  // Track which layer is being displayed

                // Get today's date for the time range
                const today = new Date();
                const todayStr = today.toISOString().split('T')[0];  // Format: YYYY-MM-DD
                const timeRange = `2015-06-23/${todayStr}`;  // From Sentinel-2 start to today

                wmsLayer = L.tileLayer.wms(`${CACHE_SERVER}/api/sentinel`, {
                    layers: layerName,
                    format: 'image/png',
                    transparent: false,
                    time: timeRange,
                    attribution: 'Sentinel-2 ¬© ESA',
                    maxZoom: 25,
                    maxNativeZoom: 18
                });

                wmsLayer.addTo(map);

                document.getElementById('map-source').textContent = `Source: Sentinel-2 (${layerName})`;
                document.getElementById('map-date-acquired').textContent = 'Image date: Fetching...';
                document.getElementById('map-cache-status').textContent = 'Cache status: Loading...';

                // Check if we already have this layer's date cached
                if (sentinelLayerDateCache[layerName]) {
                    document.getElementById('map-date-acquired').textContent = `Image date: ${sentinelLayerDateCache[layerName]}`;
                    document.getElementById('map-cache-status').textContent = 'Cache status: ‚úÖ Cached (Sentinel-2)';
                } else {
                    // Fetch the actual imagery acquisition date
                    getSentinelLayerDate(layerName).then(date => {
                        // Only update if this layer is still the current one
                        if (currentSentinelLayer === layerName) {
                            if (date) {
                                document.getElementById('map-date-acquired').textContent = `Image date: ${date}`;
                                document.getElementById('map-cache-status').textContent = 'Cache status: ‚úÖ Cached (Sentinel-2)';
                            }
                        }
                    });
                }

                // Check if there's newer data available
                checkAndUpdateSentinelCache(layerName);
            }

            // Re-apply all active overlays after background layer change
            reapplyOverlays();
        }

        // Update overlay layer from dropdown
        function updateOverlayLayer() {
            const overlayName = document.getElementById('overlay-layer-select').value;

            // Remove current overlay if exists
            if (overlayLayers.current) {
                map.removeLayer(overlayLayers.current);
                overlayLayers.current = null;
            }

            if (overlayName === 'NONE') {
                return;
            }

            let newLayer = null;
            switch (overlayName) {
                case 'RADAR':
                    newLayer = L.tileLayer('https://tilecache.rainviewer.com/v2/radar/latest/512/{z}/{x}/{y}/2/1_1.png', {
                        attribution: 'RainViewer',
                        opacity: 0.6,
                        maxZoom: 18
                    });
                    break;
                case 'TEMP':
                    newLayer = L.tileLayer(`https://tile.openweathermap.org/map/temp_new/{z}/{x}/{y}.png?appid=${OWM_API_KEY}`, {
                        attribution: 'OpenWeatherMap',
                        opacity: 0.5,
                        maxZoom: 19
                    });
                    break;
                case 'PRECIP_24H':
                    newLayer = L.tileLayer('https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/q2-n1p-900913/{z}/{x}/{y}.png', {
                        attribution: 'NOAA/NWS',
                        opacity: 0.6,
                        maxZoom: 12
                    });
                    break;
            }

            if (newLayer) {
                overlayLayers.current = newLayer;
                newLayer.addTo(map);
            }
        }

        // Re-add overlay after background layer change
        function reapplyOverlays() {
            // Re-add current overlay if it exists
            if (overlayLayers.current && !map.hasLayer(overlayLayers.current)) {
                overlayLayers.current.addTo(map);
            }
            // Also re-add camera layer if it exists and is checked
            if (cameraLayer && document.getElementById('show-cameras').checked && !map.hasLayer(cameraLayer)) {
                cameraLayer.addTo(map);
            }
        }

        // Fetch data from cache server with cache busting
        async function fetchFromCache(endpoint) {
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${CACHE_SERVER}${endpoint}?t=${cacheBuster}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();

                // Check custom cache header
                const cacheHeader = response.headers.get('X-Cache-Status');
                const isCached = cacheHeader === 'HIT';

                console.log(`${endpoint}: Cache-Status=${cacheHeader}, is_cached=${isCached}`);

                // Return data with metadata
                return {
                    data: data,
                    cached: isCached,
                    timestamp: new Date(),
                    source: endpoint
                };
            } catch (error) {
                console.error(`Error fetching ${endpoint}:`, error);
                return null;
            }
        }

        // Load and render quick view stats
        async function loadQuickView() {
            const container = document.getElementById('quickStats');

            // Fetch OpenWeatherMap data
            const owmResponse = await fetchFromCache('/api/weather/owm');
            if (owmResponse && owmResponse.data && owmResponse.data.current) {
                const current = owmResponse.data.current;
                const tempVal = Math.round(current.temp);
                const windVal = Math.round(current.wind_speed);
                const humidityVal = current.humidity;

                const html = `
                    <div class="stat-box temp">
                        <div class="stat-label">Temperature</div>
                        <div class="stat-value" style="color: ${getTempColor(tempVal)}">${tempVal}¬∞F</div>
                        <div class="stat-source">OWM</div>
                    </div>
                    <div class="stat-box wind">
                        <div class="stat-label">Wind Speed</div>
                        <div class="stat-value" style="color: ${getWindColor(windVal)}">${windVal} mph</div>
                        <div class="stat-source">OWM</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Humidity</div>
                        <div class="stat-value" style="color: ${getHumidityColor(humidityVal)}">${humidityVal}%</div>
                        <div class="stat-source">OWM</div>
                    </div>
                `;
                container.innerHTML = html;

                // Update weather info display
                document.getElementById('weather-time').textContent = `Last updated: ${owmResponse.timestamp.toLocaleTimeString()} | `;
                document.getElementById('weather-cache').textContent = `Status: ${owmResponse.cached ? '‚úÖ Cached' : 'üîÑ Fresh'}`;
            } else {
                container.innerHTML = '<div class="error">Failed to load weather data</div>';
            }

            // Fetch SNOTEL snow data
            const snowResponse = await fetchFromCache('/api/weather/snotel');
            if (snowResponse && snowResponse.data && Array.isArray(snowResponse.data) && snowResponse.data[0] && snowResponse.data[0].data) {
                const datasets = snowResponse.data[0].data;
                if (datasets && datasets.length > 0) {
                    // Find SNWD (snow depth) data
                    const snwdData = datasets.find(d => d.stationElement && d.stationElement.elementCode === 'SNWD');
                    if (snwdData && snwdData.values && snwdData.values.length > 0) {
                        const latestValue = snwdData.values[snwdData.values.length - 1]?.value;
                        if (latestValue !== undefined) {
                            const snowDepthInches = latestValue / 2.54;
                            const snowHtml = `
                                <div class="stat-box snow">
                                    <div class="stat-label">Snow Depth</div>
                                    <div class="stat-value" style="color: ${getSnowColor(snowDepthInches)}">${snowDepthInches.toFixed(1)}"</div>
                                    <div class="stat-source">SNOTEL</div>
                                </div>
                            `;
                            container.innerHTML += snowHtml;
                        }
                    }
                }
            }

            updateLastUpdate();
        }

        // Weather chart instance
        let forecastChart = null;
        let weatherData = null;

        // Load and render 7-day forecast
        async function loadWeather() {
            const owmResponse = await fetchFromCache('/api/weather/owm');

            if (!owmResponse || !owmResponse.data) {
                console.error('Failed to load weather data');
                return;
            }

            weatherData = owmResponse.data;

            // Update weather info display
            document.getElementById('weather-time').textContent = `Last updated: ${owmResponse.timestamp.toLocaleTimeString()} | `;
            document.getElementById('weather-cache').textContent = `Status: ${owmResponse.cached ? '‚úÖ Cached' : 'üîÑ Fresh'}`;

            // Render chart
            if (owmResponse.data.daily && owmResponse.data.daily.length > 0) {
                renderForecastChart(owmResponse.data.daily.slice(0, 7));
                renderForecastCards(owmResponse.data.daily.slice(0, 7));
            }
        }

        function renderForecastChart(dailyData) {
            if (!dailyData || dailyData.length === 0) return;

            const chartData = dailyData.map(day => ({
                x: new Date(day.dt * 1000),
                y: day.temp.day
            }));

            const minData = dailyData.map(day => ({
                x: new Date(day.dt * 1000),
                y: day.temp.min
            }));

            const maxData = dailyData.map(day => ({
                x: new Date(day.dt * 1000),
                y: day.temp.max
            }));

            if (forecastChart) {
                forecastChart.destroy();
            }

            const canvas = document.getElementById('hourly-temp-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Max Temp',
                            data: maxData,
                            borderColor: '#ff6b6b',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 5,
                            pointBackgroundColor: '#ff6b6b',
                            pointBorderColor: '#2d2520',
                            pointBorderWidth: 2,
                            tension: 0.3
                        },
                        {
                            label: 'Day Temp',
                            data: chartData,
                            borderColor: '#d4a574',
                            backgroundColor: 'rgba(212, 165, 116, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            pointRadius: 5,
                            pointBackgroundColor: '#d4a574',
                            pointBorderColor: '#2d2520',
                            pointBorderWidth: 2,
                            tension: 0.3
                        },
                        {
                            label: 'Min Temp',
                            data: minData,
                            borderColor: '#7a9b8e',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 5,
                            pointBackgroundColor: '#7a9b8e',
                            pointBorderColor: '#2d2520',
                            pointBorderWidth: 2,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            showHourlyModal(index);
                        }
                    },
                    plugins: {
                        freezingPointLine: {},
                        soilMoistureZones: false,
                        legend: {
                            labels: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(42, 37, 32, 0.95)',
                            titleColor: '#e8e6e3',
                            bodyColor: '#e8e6e3',
                            borderColor: '#c8bfa8',
                            borderWidth: 1,
                            callbacks: {
                                title: (context) => {
                                    const date = new Date(context[0].raw.x);
                                    return date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
                                },
                                label: (context) => {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '¬∞F';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: { day: 'MMM d' }
                            },
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 11 }
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' }
                        },
                        y: {
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                callback: value => value + '¬∞F'
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' },
                            title: {
                                display: true,
                                text: 'Temperature (¬∞F)',
                                color: '#c8bfa8',
                                font: { size: 13 }
                            }
                        }
                    }
                }
            });
        }

        function renderForecastCards(dailyData) {
            let html = '';

            dailyData.forEach((day, index) => {
                const dayDate = new Date(day.dt * 1000);
                const dayName = dayDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });

                const highTemp = day.temp.max.toFixed(0);
                const dayTemp = day.temp.day.toFixed(0);
                const lowTemp = day.temp.min.toFixed(0);
                const condition = day.weather[0].main;

                html += `
                    <div class="forecast-day-card" onclick="showHourlyModal(${index})">
                        <div class="forecast-day-name">${dayName}</div>
                        <div class="forecast-temps">
                            <div>
                                <span class="forecast-temp-label">High</span>
                                <span class="forecast-temp-value" style="color: ${getTempColor(parseFloat(highTemp))}">${highTemp}¬∞</span>
                            </div>
                            <div>
                                <span class="forecast-temp-label">Day</span>
                                <span class="forecast-temp-value" style="color: ${getTempColor(parseFloat(dayTemp))}">${dayTemp}¬∞</span>
                            </div>
                            <div>
                                <span class="forecast-temp-label">Low</span>
                                <span class="forecast-temp-value" style="color: ${getTempColor(parseFloat(lowTemp))}">${lowTemp}¬∞</span>
                            </div>
                        </div>
                        <div class="forecast-condition" style="color: ${getConditionColor(condition)}">${condition}</div>
                        <div class="forecast-details">
                            <span style="color: ${getHumidityColor(day.humidity)}">üíß ${day.humidity}%</span> | <span style="color: ${getWindColorMs(day.wind_speed)}">üí® ${day.wind_speed.toFixed(1)} m/s</span>
                        </div>
                    </div>
                `;
            });

            document.getElementById('forecastCardsContainer').innerHTML = html;
        }

        function showHourlyModal(dayIndex) {
            if (!weatherData || !weatherData.daily || !weatherData.daily[dayIndex]) return;

            const day = weatherData.daily[dayIndex];
            const dayDate = new Date(day.dt * 1000);
            const dayName = dayDate.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });

            document.getElementById('modalDayName').textContent = dayName + ' - Hourly Forecast';

            // Check if hourly data is available
            if (!weatherData.hourly || weatherData.hourly.length === 0) {
                document.getElementById('hourlyModalContent').innerHTML = `
                    <div class="no-hourly-message">
                        ‚ö†Ô∏è Hourly forecast data is not available in the current API response.
                    </div>
                `;
            } else {
                // Calculate start and end indices for this day
                const dayStart = new Date(dayDate);
                dayStart.setHours(0, 0, 0, 0);
                const dayEnd = new Date(dayDate);
                dayEnd.setHours(23, 59, 59, 999);

                const hourlyForDay = weatherData.hourly.filter(h => {
                    const hourDate = new Date(h.dt * 1000);
                    return hourDate >= dayStart && hourDate <= dayEnd;
                });

                if (hourlyForDay.length === 0) {
                    document.getElementById('hourlyModalContent').innerHTML = `
                        <div class="no-hourly-message">
                            ‚ö†Ô∏è No hourly data available for this specific day.
                        </div>
                    `;
                } else {
                    // Show canvas and render chart
                    document.getElementById('hourlyModalContent').innerHTML = `
                        <div class="chart-box" style="height: 400px;">
                            <div class="chart-wrapper" style="height: 350px;">
                                <canvas id="hourly-chart-canvas"></canvas>
                            </div>
                        </div>
                    `;

                    // Render hourly chart
                    renderHourlyChart(hourlyForDay);
                }
            }

            document.getElementById('hourlyModal').style.display = 'flex';
        }

        function renderHourlyChart(hourlyData) {
            if (!hourlyData || hourlyData.length === 0) return;

            const chartData = hourlyData.map(h => ({
                x: new Date(h.dt * 1000),
                y: h.temp
            }));

            const feelsLikeData = hourlyData.map(h => ({
                x: new Date(h.dt * 1000),
                y: h.feels_like
            }));

            if (hourlyChart) {
                hourlyChart.destroy();
            }

            const canvas = document.getElementById('hourly-chart-canvas');
            if (!canvas) {
                console.error('Hourly chart canvas not found');
                return;
            }

            const ctx = canvas.getContext('2d');
            hourlyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Temperature',
                            data: chartData,
                            borderColor: '#d4a574',
                            backgroundColor: 'rgba(212, 165, 116, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            pointRadius: 4,
                            pointBackgroundColor: '#d4a574',
                            pointBorderColor: '#2d2520',
                            pointBorderWidth: 2,
                            tension: 0.3
                        },
                        {
                            label: 'Feels Like',
                            data: feelsLikeData,
                            borderColor: '#ff9500',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointBackgroundColor: '#ff9500',
                            pointBorderColor: '#2d2520',
                            pointBorderWidth: 2,
                            tension: 0.3,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        freezingPointLine: {},
                        soilMoistureZones: false,
                        legend: {
                            labels: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(42, 37, 32, 0.95)',
                            titleColor: '#e8e6e3',
                            bodyColor: '#e8e6e3',
                            borderColor: '#c8bfa8',
                            borderWidth: 1,
                            callbacks: {
                                title: (context) => {
                                    const date = new Date(context[0].raw.x);
                                    return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                                },
                                label: (context) => {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '¬∞F';
                                },
                                afterLabel: (context) => {
                                    const index = context.dataIndex;
                                    const hourData = hourlyData[index];
                                    return [
                                        'Humidity: ' + hourData.humidity + '%',
                                        'Wind: ' + hourData.wind_speed.toFixed(1) + ' mph',
                                        'Clouds: ' + hourData.clouds + '%'
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: { hour: 'HH:mm' }
                            },
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' }
                        },
                        y: {
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                callback: value => value + '¬∞F'
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' }
                        }
                    }
                }
            });
        }

        function closeHourlyModal() {
            document.getElementById('hourlyModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('hourlyModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // Soil zone configuration (customizable)
        let soilZones = [
            { min: 0, max: 10, color: 'rgba(184, 134, 11, 0.2)', label: 'Dry', condition: 'Dry, excellent traction, easy driving', drivable: true },
            { min: 10, max: 20, color: 'rgba(210, 180, 140, 0.2)', label: 'Damp', condition: 'Damp, good traction, optimal for driving', drivable: true },
            { min: 20, max: 30, color: 'rgba(160, 120, 80, 0.2)', label: 'Moist', condition: 'Moist, adequate traction, approaching saturation', drivable: true },
            { min: 30, max: 40, color: 'rgba(120, 90, 60, 0.2)', label: 'Wet', condition: 'Wet, traction reduces significantly, starting to get risky', drivable: false },
            { min: 40, max: 50, color: 'rgba(80, 50, 30, 0.2)', label: 'Saturated', condition: 'Saturated, very poor traction, high risk of getting stuck', drivable: false },
            { min: 50, max: 100, color: 'rgba(50, 30, 10, 0.2)', label: 'Muddy/Impassable', condition: 'Muddy/impassable, vehicle will sink', drivable: false }
        ];

        // Load zones from localStorage if available
        function loadSoilZones() {
            const saved = localStorage.getItem('soilZones');
            if (saved) {
                try {
                    soilZones = JSON.parse(saved);
                    console.log('Loaded custom soil zones from storage');
                } catch (e) {
                    console.log('Using default soil zones');
                }
            }
        }

        // Traffic camera layer and data
        let cameraLayer = null;
        let allCameras = [];
        let allWeatherStations = [];
        const DEFAULT_CAMERA_ID = 91344;  // I-70 @ MM 56, Green River

        let currentCamera = null;

        // Find nearest weather station to a camera
        function findNearestWeatherStation(camera) {
            if (!camera.latitude || !camera.longitude || allWeatherStations.length === 0) {
                return null;
            }

            let nearest = null;
            let minDistance = Infinity;

            allWeatherStations.forEach(station => {
                let lat, lon;
                // Handle both direct properties and nested geometry
                if (station.Latitude && station.Longitude) {
                    lat = station.Latitude;
                    lon = station.Longitude;
                } else if (station.geometry && station.geometry.coordinates) {
                    lon = station.geometry.coordinates[0];
                    lat = station.geometry.coordinates[1];
                } else if (station.properties && station.properties.Latitude) {
                    lat = station.properties.Latitude;
                    lon = station.properties.Longitude;
                }

                if (lat && lon) {
                    const distance = Math.sqrt(
                        Math.pow(lat - camera.latitude, 2) +
                        Math.pow(lon - camera.longitude, 2)
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = station;
                    }
                }
            });

            return nearest;
        }

        // Create camera markers on map from API data
        async function createCameraLayer() {
            try {
                console.log('Creating camera layer...');
                // Fetch all cameras and weather stations from API
                const camerasResponse = await fetch(`${CACHE_SERVER}/api/udot/cameras?t=${new Date().getTime()}`);
                const weatherResponse = await fetch(`${CACHE_SERVER}/api/udot/weather?t=${new Date().getTime()}`);

                console.log(`Camera response status: ${camerasResponse.status}`);
                console.log(`Weather response status: ${weatherResponse.status}`);

                if (!camerasResponse.ok || !weatherResponse.ok) {
                    console.error('Failed to load camera or weather data from API', {
                        cameras: camerasResponse.status,
                        weather: weatherResponse.status
                    });
                    return;
                }

                const camerasData = await camerasResponse.json();
                const weatherData = await weatherResponse.json();

                console.log('Camera data:', camerasData);
                console.log('Weather data:', weatherData);

                // Transform camera API data - UDOT returns array directly
                if (Array.isArray(camerasData)) {
                    allCameras = camerasData.map(cam => {
                        const firstView = cam.Views && cam.Views.length > 0 ? cam.Views[0] : null;
                        return {
                            id: cam.Id,
                            source: cam.Source,
                            roadway: cam.Roadway || 'Unknown',
                            direction: cam.Direction || 'Unknown',
                            latitude: cam.Latitude,
                            longitude: cam.Longitude,
                            location: cam.Location,
                            url: firstView ? firstView.Url : null,
                            status: firstView ? firstView.Status : 'Disabled'
                        };
                    }).filter(cam => cam.latitude && cam.longitude);
                } else {
                    console.error('Invalid camera data format - expected array', camerasData);
                    return;
                }

                // Transform weather station API data - also an array
                if (Array.isArray(weatherData)) {
                    allWeatherStations = weatherData;
                } else if (weatherData && weatherData.features) {
                    allWeatherStations = weatherData.features.map(feature => ({
                        ...feature.properties,
                        Latitude: feature.geometry.coordinates[1],
                        Longitude: feature.geometry.coordinates[0]
                    }));
                } else {
                    console.warn('No weather station data available');
                }

                console.log(`Loaded ${allCameras.length} cameras and ${allWeatherStations.length} weather stations`);

                if (!map) {
                    console.error('Map not initialized yet');
                    return;
                }

                if (cameraLayer) {
                    map.removeLayer(cameraLayer);
                }

                cameraLayer = L.layerGroup();

                // Add markers for each camera
                allCameras.forEach(camera => {
                    const isEnabled = camera.status === 'Enabled' || camera.status === 'enabled';

                    // Create custom icon based on status
                    const cameraIcon = L.divIcon({
                        className: 'camera-marker',
                        html: `<div style="
                            background: ${isEnabled ? '#34c759' : '#8a8170'};
                            width: 12px;
                            height: 12px;
                            border-radius: 50%;
                            border: 2px solid ${isEnabled ? '#90EE90' : '#5a4d47'};
                            box-shadow: 0 0 4px rgba(0,0,0,0.5);
                        "></div>`,
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    });

                    const marker = L.marker([camera.latitude, camera.longitude], {
                        icon: cameraIcon,
                        title: camera.name
                    });

                    // Click handler to show camera view
                    marker.on('click', () => {
                        selectCamera(camera);
                    });

                    // Popup with camera info
                    marker.bindPopup(`
                        <div style="color: #1a1410; font-size: 12px;">
                            <strong>${camera.name}</strong><br>
                            ${camera.roadway} - ${camera.direction}<br>
                            Status: ${camera.status}
                        </div>
                    `);

                    cameraLayer.addLayer(marker);
                });

                // Add camera layer to map
                cameraLayer.addTo(map);

                // Select default camera
                const defaultCamera = allCameras.find(cam => cam.id === DEFAULT_CAMERA_ID);
                if (defaultCamera) {
                    selectCamera(defaultCamera);
                } else if (allCameras.length > 0) {
                    selectCamera(allCameras[0]);
                }

            } catch (error) {
                console.error('Error creating camera layer:', error);
            }
        }

        // Select and display a camera
        function selectCamera(camera) {
            currentCamera = camera;
            document.getElementById('camera-name').textContent = camera.location;

            // Use camera URL from API
            if (camera.url) {
                document.getElementById('camera-iframe').src = camera.url;
            } else {
                document.getElementById('camera-iframe').src = `https://www.udottraffic.utah.gov/map/Cctv/${camera.id}`;
            }

            // Load weather for this camera location
            loadCameraWeather(camera);
        }

        // Get color for temperature value (Fahrenheit)
        function getTempColor(temp) {
            if (temp === null || isNaN(temp)) return '#c8bfa8';
            if (temp <= 0) return '#00bfff';      // Freezing - cyan/ice blue
            if (temp <= 32) return '#4da6ff';     // Below freezing - light blue
            if (temp <= 50) return '#99ccff';     // Cold - pale blue
            if (temp <= 65) return '#98fb98';     // Cool - pale green
            if (temp <= 80) return '#ffd700';     // Warm - gold
            if (temp <= 95) return '#ff8c00';     // Hot - orange
            return '#ff4500';                     // Very hot - red-orange
        }

        // Get color for humidity value
        function getHumidityColor(humidity) {
            if (humidity === null || isNaN(humidity)) return '#c8bfa8';
            if (humidity <= 30) return '#ff8c00';  // Very dry - orange
            if (humidity <= 50) return '#ffd700';  // Dry - gold
            if (humidity <= 70) return '#98fb98';  // Normal - green
            if (humidity <= 85) return '#4da6ff';  // Humid - light blue
            return '#00bfff';                      // Very humid - cyan
        }

        // Get color for wind speed value (mph)
        function getWindColor(speed) {
            if (speed === null || isNaN(speed)) return '#c8bfa8';
            if (speed <= 5) return '#98fb98';      // Calm - green
            if (speed <= 15) return '#ffd700';     // Light breeze - gold
            if (speed <= 25) return '#ff8c00';     // Moderate - orange
            if (speed <= 40) return '#ff4500';     // Strong - red-orange
            return '#ff0000';                      // Very strong - red
        }

        // Get color for wind speed in m/s (for forecast)
        function getWindColorMs(speed) {
            if (speed === null || isNaN(speed)) return '#c8bfa8';
            // Convert thresholds: 5mph=2.2m/s, 15mph=6.7m/s, 25mph=11.2m/s, 40mph=17.9m/s
            if (speed <= 2.2) return '#98fb98';    // Calm - green
            if (speed <= 6.7) return '#ffd700';    // Light breeze - gold
            if (speed <= 11.2) return '#ff8c00';   // Moderate - orange
            if (speed <= 17.9) return '#ff4500';   // Strong - red-orange
            return '#ff0000';                      // Very strong - red
        }

        // Get color for snow depth (inches)
        function getSnowColor(depth) {
            if (depth === null || isNaN(depth)) return '#c8bfa8';
            if (depth <= 0) return '#98fb98';      // No snow - green
            if (depth <= 6) return '#e0e0e0';      // Light snow - light gray
            if (depth <= 12) return '#b0c4de';     // Moderate - light steel blue
            if (depth <= 24) return '#87ceeb';     // Good snow - sky blue
            if (depth <= 48) return '#4da6ff';     // Deep snow - light blue
            return '#00bfff';                      // Very deep - cyan
        }

        // Get color for surface status
        function getSurfaceStatusColor(status) {
            if (!status) return '#c8bfa8';
            const s = status.toLowerCase();
            if (s.includes('dry')) return '#98fb98';           // Green
            if (s.includes('wet')) return '#4da6ff';           // Light blue
            if (s.includes('ice') || s.includes('frost')) return '#00bfff';  // Cyan
            if (s.includes('snow')) return '#e0e0e0';          // White/gray
            if (s.includes('slush')) return '#87ceeb';         // Sky blue
            return '#c8bfa8';                                  // Default
        }

        // Get color for weather condition
        function getConditionColor(condition) {
            if (!condition) return '#c8bfa8';
            const c = condition.toLowerCase();
            if (c.includes('clear') || c.includes('sunny')) return '#ffd700';   // Gold
            if (c.includes('cloud')) return '#a9a9a9';          // Gray
            if (c.includes('rain') || c.includes('drizzle')) return '#4da6ff';  // Light blue
            if (c.includes('snow')) return '#e0e0e0';           // White/gray
            if (c.includes('thunder') || c.includes('storm')) return '#ff4500'; // Red-orange
            if (c.includes('fog') || c.includes('mist')) return '#d3d3d3';      // Light gray
            return '#c8bfa8';                                   // Default
        }

        async function loadCameraWeather(camera) {
            try {
                // Find nearest weather station
                const weatherStation = findNearestWeatherStation(camera);

                let html = '<div style="color: #8a8170;">No weather data available</div>';

                if (weatherStation) {
                    const airTempVal = weatherStation.AirTemperature ? parseFloat(weatherStation.AirTemperature) : null;
                    const surfaceTempVal = weatherStation.SurfaceTemp ? parseFloat(weatherStation.SurfaceTemp) : null;
                    const humidityVal = weatherStation.RelativeHumidity ? parseFloat(weatherStation.RelativeHumidity) : null;
                    const windSpeedVal = weatherStation.WindSpeedAvg ? parseFloat(weatherStation.WindSpeedAvg) : null;

                    const airTemp = airTempVal !== null ? `${airTempVal.toFixed(1)}¬∞F` : 'N/A';
                    const surfaceTemp = surfaceTempVal !== null ? `${surfaceTempVal.toFixed(1)}¬∞F` : 'N/A';
                    const surfaceStatus = weatherStation.SurfaceStatus || 'Unknown';
                    const humidity = humidityVal !== null ? `${humidityVal}%` : 'N/A';
                    const windSpeed = windSpeedVal !== null ? `${windSpeedVal.toFixed(1)} mph` : 'N/A';
                    const windDir = weatherStation.WindDirection || 'N/A';

                    const airTempColor = getTempColor(airTempVal);
                    const surfaceTempColor = getTempColor(surfaceTempVal);
                    const humidityColor = getHumidityColor(humidityVal);
                    const windColor = getWindColor(windSpeedVal);
                    const surfaceStatusColor = getSurfaceStatusColor(surfaceStatus);

                    html = `
                        <div><strong>Air Temp:</strong> <span style="color: ${airTempColor}; font-weight: bold;">${airTemp}</span></div>
                        <div><strong>Surface Temp:</strong> <span style="color: ${surfaceTempColor}; font-weight: bold;">${surfaceTemp}</span></div>
                        <div><strong>Surface Status:</strong> <span style="color: ${surfaceStatusColor}; font-weight: bold;">${surfaceStatus}</span></div>
                        <div><strong>Humidity:</strong> <span style="color: ${humidityColor}; font-weight: bold;">${humidity}</span></div>
                        <div><strong>Wind:</strong> <span style="color: ${windColor}; font-weight: bold;">${windSpeed}</span> ${windDir ? `(${windDir})` : ''}</div>
                        <div style="margin-top: 10px; font-size: 11px; color: #7a6a58;">Station: ${weatherStation.StationName || 'Unknown'}</div>
                    `;
                }

                document.getElementById('camera-weather-conditions').innerHTML = html;
            } catch (error) {
                console.error('Error loading camera weather:', error);
            }
        }

        // Toggle camera layer visibility
        function toggleCameras() {
            const showCameras = document.getElementById('show-cameras').checked;
            console.log(`Toggle cameras: ${showCameras}`);
            if (showCameras && cameraLayer) {
                cameraLayer.addTo(map);
            } else if (cameraLayer) {
                map.removeLayer(cameraLayer);
            }
        }

        // Load and render soil data charts including snow depth
        async function loadSoilData() {
            const soilResponse = await fetchFromCache('/api/weather/soil');
            const snowResponse = await fetchFromCache('/api/weather/snotel');

            if (!soilResponse || !soilResponse.data || !Array.isArray(soilResponse.data) || soilResponse.data.length === 0) {
                console.error('Failed to load soil data');
                return;
            }

            // Update soil info display
            document.getElementById('soil-time').textContent = `Last updated: ${soilResponse.timestamp.toLocaleTimeString()} | `;
            document.getElementById('soil-cache').textContent = `Status: ${soilResponse.cached ? '‚úÖ Cached' : 'üîÑ Fresh'}`;

            // Extract actual data from response structure
            const soilData = soilResponse.data[0].data;

            if (!soilData || !Array.isArray(soilData) || soilData.length === 0) {
                console.error('No soil data available');
                return;
            }

            // Separate by type (moisture vs temperature)
            const moistureData = soilData.filter(d => d.stationElement && d.stationElement.elementCode === 'SMS');
            const tempData = soilData.filter(d => d.stationElement && d.stationElement.elementCode === 'STO');

            // Render charts
            if (moistureData.length > 0) {
                renderSoilMoistureChart(moistureData);
            }

            if (tempData.length > 0) {
                renderSoilTempChart(tempData);
            }

            // Render snow depth if available
            if (snowResponse && snowResponse.data && Array.isArray(snowResponse.data)) {
                const snowData = snowResponse.data[0].data;
                if (snowData && Array.isArray(snowData)) {
                    renderSnowDepthChart(snowData);
                }
            }
        }

        function renderSoilMoistureChart(moistureData) {
            if (!moistureData || moistureData.length === 0) {
                console.error('No soil moisture data to render');
                return;
            }

            const datasets = [];
            const colors = ['#4a9eff', '#ff9500', '#34c759'];

            // Calculate date range
            const today = new Date();
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(today.getDate() - 7);

            moistureData.forEach((dataset, idx) => {
                const depth = Math.abs(dataset.stationElement.heightDepth);
                const chartData = dataset.values.map(v => ({
                    x: new Date(v.date),
                    y: v.value
                }));

                datasets.push({
                    label: `${depth} cm depth`,
                    data: chartData,
                    borderColor: colors[idx % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            });

            if (soilMoistureChart) {
                soilMoistureChart.destroy();
            }

            const canvas = document.getElementById('soil-moisture-canvas');
            if (!canvas) {
                console.error('Soil moisture canvas not found');
                return;
            }

            const ctx = canvas.getContext('2d');

            soilMoistureChart = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        soilMoistureZones: {},
                        freezingPointLine: false,
                        legend: {
                            labels: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(42, 37, 32, 0.95)',
                            titleColor: '#e8e6e3',
                            bodyColor: '#e8e6e3',
                            borderColor: '#c8bfa8',
                            borderWidth: 1,
                            callbacks: {
                                label: (context) => {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: sevenDaysAgo.getTime(),
                            max: today.getTime(),
                            time: {
                                unit: 'day',
                                displayFormats: { day: 'MMM d' }
                            },
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                callback: value => value + '%'
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' },
                            title: {
                                display: true,
                                text: 'Soil Moisture (%)',
                                color: '#c8bfa8',
                                font: { size: 13 }
                            }
                        }
                    }
                }
            });
        }

        function renderSoilTempChart(tempData) {
            if (!tempData || tempData.length === 0) {
                console.error('No soil temperature data to render');
                return;
            }

            const datasets = [];
            const colors = ['#ff6b6b', '#ffa500', '#4ecdc4'];

            // Calculate date range
            const today = new Date();
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(today.getDate() - 7);

            tempData.forEach((dataset, idx) => {
                const depth = Math.abs(dataset.stationElement.heightDepth);
                const chartData = dataset.values.map(v => ({
                    x: new Date(v.date),
                    y: v.value
                }));

                datasets.push({
                    label: `${depth} cm depth`,
                    data: chartData,
                    borderColor: colors[idx % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            });

            if (soilTempChart) {
                soilTempChart.destroy();
            }

            const canvas = document.getElementById('soil-temp-canvas');
            if (!canvas) {
                console.error('Soil temperature canvas not found');
                return;
            }

            const ctx = canvas.getContext('2d');

            soilTempChart = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        freezingPointLine: {},
                        soilMoistureZones: false,
                        legend: {
                            labels: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(42, 37, 32, 0.95)',
                            titleColor: '#e8e6e3',
                            bodyColor: '#e8e6e3',
                            borderColor: '#c8bfa8',
                            borderWidth: 1,
                            callbacks: {
                                label: (context) => context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '¬∞F'
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: sevenDaysAgo.getTime(),
                            max: today.getTime(),
                            time: {
                                unit: 'day',
                                displayFormats: { day: 'MMM d' }
                            },
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' }
                        },
                        y: {
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                callback: value => value + '¬∞F'
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' },
                            title: {
                                display: true,
                                text: 'Soil Temperature (¬∞F)',
                                color: '#c8bfa8',
                                font: { size: 13 }
                            }
                        }
                    }
                },
            });
        }

        function renderSnowDepthChart(snowData) {
            if (!snowData || snowData.length === 0) {
                console.error('No snow depth data to render');
                return;
            }

            const datasets = [];
            const colors = ['#4a9eff'];

            // Process snow depth data
            const snwdData = snowData.find(d => d.stationElement && d.stationElement.elementCode === 'SNWD');
            if (!snwdData || !snwdData.values) return;

            const chartData = snwdData.values.map(v => ({
                x: new Date(v.date),
                y: v.value ? (v.value / 2.54).toFixed(1) : 0  // Convert cm to inches
            }));

            if (snowDepthChart) {
                snowDepthChart.destroy();
            }

            const ctx = document.getElementById('snow-depth-canvas')?.getContext('2d');
            if (!ctx) return;

            snowDepthChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Snow Depth',
                        data: chartData,
                        borderColor: '#4a9eff',
                        backgroundColor: 'rgba(74, 158, 255, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointBackgroundColor: '#4a9eff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        freezingPointLine: false,
                        soilMoistureZones: false,
                        legend: {
                            labels: { color: '#c8bfa8', font: { size: 12 } }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM d'
                                }
                            },
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' }
                        },
                        y: {
                            ticks: {
                                color: '#c8bfa8',
                                font: { size: 12 },
                                callback: value => value + '"'
                            },
                            grid: { color: 'rgba(200, 191, 168, 0.1)' },
                            title: {
                                display: true,
                                text: 'Snow Depth (inches)',
                                color: '#c8bfa8',
                                font: { size: 13 }
                            }
                        }
                    }
                }
            });
        }

        // Update last update timestamp
        function updateLastUpdate() {
            const now = new Date();
            document.getElementById('lastUpdate').textContent = now.toLocaleTimeString();
        }

        // Initialize on page load
        window.addEventListener('load', async function() {
            await loadConfig();  // Load API keys and config from server first
            loadSoilZones();  // Load custom soil zones from localStorage
            initializeMap();
            await createCameraLayer();  // Add camera markers to map - wait for completion
            await loadQuickView();
            await loadWeather();
            await loadSoilData();

            // Refresh data every 5 minutes
            setInterval(async () => {
                await loadQuickView();
                await loadWeather();
                await loadSoilData();
            }, 5 * 60 * 1000);
        });
    </script>
</body>
</html>